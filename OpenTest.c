 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <stdint.h>



typedef struct __attribute__((__packed__)) {
uint8_t BS_jmpBoot[ 3 ]; // x86 jump instr. to boot code
uint8_t BS_OEMName[ 8 ]; // What created the filesystem
uint16_t BPB_BytsPerSec; // Bytes per Sector
uint8_t BPB_SecPerClus; // Sectors per Cluster
uint16_t BPB_RsvdSecCnt; // Reserved Sector Count
uint8_t BPB_NumFATs; //Number of copies of FAT
uint16_t BPB_RootEntCnt; //FAT12/FAT16: size of root DIR
uint16_t BPB_TotSec16; //Sectors, may be 0, see below
uint8_t BPB_Media; // Media type, e.g. fixed
uint16_t BPB_FATSz16; // Sectors in FAT (FAT12 or FAT16)
uint16_t BPB_SecPerTrk; // Sectors per Track
uint16_t BPB_NumHeads; // Number of heads in disk
uint32_t BPB_HiddSec; // Hidden Sector count
uint32_t BPB_TotSec32; // Sectors if BPB_TotSec16 == 0
uint8_t BS_DrvNum; // 0 = floppy, 0x80 = hard disk
uint8_t BS_Reserved1; //
uint8_t BS_BootSig; // Should = 0x29
uint32_t BS_VolID; // 'Unique' ID for volume
uint8_t BS_VolLab[ 11 ]; // Non zero terminated string
uint8_t BS_FilSysType[ 8 ]; // e.g. 'FAT16 ' (Not 0 term.)
} BootSector;

typedef struct {
    uint8_t DIR_Name[ 11 ]; // Non zero terminated string
    uint8_t DIR_Attr; // File attributes
    uint8_t DIR_NTRes; // Used by Windows NT, ignore
    uint8_t DIR_CrtTimeTenth; // Tenths of sec. 0...199
    uint16_t DIR_CrtTime; // Creation Time in 2s intervals
    uint16_t DIR_CrtDate; // Date file created
    uint16_t DIR_LstAccDate; // Date of last read or write
    uint16_t DIR_FstClusHI; // Top 16 bits file's 1st cluster
    uint16_t DIR_WrtTime; // Time of last write
    uint16_t DIR_WrtDate; // Date of last write
    uint16_t DIR_FstClusLO; // Lower 16 bits file's 1st cluster
    uint32_t DIR_FileSize; // File size in bytes
} Directory;

typedef struct { //struct for the volume
    Directory dir; //Directory entry
    const char * file; //file name
    BootSector boot; //boot sector 
    uint16_t fat []; //fat sector
}Volume;

typedef struct{ //struct for a file
    Directory dir;
    size_t size;
    int starting_cluster; //starting cluster
    off_t offset; //offset
    char * content; //content text
    Volume * vol; //volume it belongs to
}File;


char * sector_reader(int len, off_t off, const char * file){ //sector reader returns pointer to full array of what it has read
    int desc = open(file, 0);
    lseek(desc, off, 0);
    char * buffer = malloc(len);
    read(desc, buffer, len);
    close(desc);
    return buffer;
}

void print_BootSector(BootSector boot){ //prints out the boot sector
    printf("Bytes Per Sector: %i\n", boot.BPB_BytsPerSec);
    printf("Sectors Per Cluster: %i\n", boot.BPB_SecPerClus);
    printf("Count Of Reserved Sectors: %i\n", boot.BPB_RsvdSecCnt);
    printf("Number Of FAT's: %i\n", boot.BPB_NumFATs);
    printf("Size Of Root Directory: %i\n", boot.BPB_RootEntCnt);
    printf("Sectors: %i\n", boot.BPB_TotSec16);
    printf("Sectors In FAT: %i\n", boot.BPB_FATSz16);
    printf("Bytes Per Sector: %i\n", boot.BPB_BytsPerSec);
    printf("Sectors if BPB_TotSec16 is equal to 0: %i\n", boot.BPB_TotSec32);
    printf("Non 0 Terminated String: ");
    for(int i = 0; i < 11; i++){
        printf("%c", boot.BS_VolLab[i]);
    }
    printf("\n");
}

void cluster_reader(int pos, int FAToffset, int count, uint16_t * clusterArray){ //reads the cluster and puts it into a list recursive
    uint16_t FATn = 0; //number of the FAT entry
    int originalOffset = FAToffset; //copy of FAToffeset as we edit FAToffset
    for(int i = 0; i < pos; i++){
        FAToffset = FAToffset+sizeof(uint16_t);
    }
    char * FATentr = sector_reader(sizeof(uint16_t), FAToffset, "fat16.img");
    memcpy(&FATn, FATentr, sizeof(FATn));
    free(FATentr);
    clusterArray[count] = FATn;
    if(FATn >= 0xfff8 || FATn < 2){
        printf("%i\n", FATn);
        printf("End of clusters\n");
        return;
    }
    
    printf("%i ->", FATn);
    cluster_reader(FATn, originalOffset, count++, clusterArray);
}

uint32_t join(uint16_t higher, uint16_t lower){ //joins the two together to give a 32 bit int
    return ((higher << 16)| lower);
}

void convert_date_time(uint16_t date, uint16_t time) { //gets the data and time data decodes it, formats it and outputs it
    uint16_t year = 1980 + ((date >> 9) & 0x7F);
    uint16_t month = (date >> 5) & 0x0F;
    uint16_t day = date & 0x1F;
    uint16_t hour = (time >> 11) & 0x1F;
    uint16_t minute = (time >> 5) & 0x3F;
    uint16_t second = (time & 0x1F) * 2; 

    printf("%04d-%02d-%02d %02d:%02d:%02d\t", year, month, day, hour, minute, second);
}

void getFlags(uint8_t FlagBits, char * Flags){ //checks which flags each file has

    for(int i = 0; i < 6; i++){
        uint8_t current_flag = (FlagBits >> i) & 0x01;//gets flag bit
        if(current_flag == 1){
            switch (i)
            {
            case 0:
                Flags[i] = 'R';
                break;
            case 1:
                Flags[i] = 'H';
                break;
            case 2:
                Flags[i] = 'S';
                break;
            case 3:
                Flags[i] = 'V';
                break;
            case 4:
                Flags[i] = 'D';
                break;
            case 5:
                Flags[i] = 'A';
                break;
            default:
                break;
            }
        }
    }
}

void print_directory(Directory dir){//prints a single directory in format
    if(!(((dir.DIR_Attr & 0x0F) == 0x0F)&&(((dir.DIR_Attr >> 4) & 0x03) == 0x00))){ 
        uint32_t starting_cluster = join(dir.DIR_FstClusHI, dir.DIR_FstClusLO);
        char Flags [6] = "------";
        getFlags(dir.DIR_Attr, Flags);
        printf("| %u\t\t\t", starting_cluster);
        printf("|");
        convert_date_time(dir.DIR_WrtDate, dir.DIR_WrtTime);
        printf("|");
        printf(" %.6s\t", Flags);
        printf("|");
        printf(" %i\t", dir.DIR_FileSize);
        printf("|");
        printf(" %.11s\t",dir.DIR_Name);
        printf("|\n");
    }
}

void read_root_directory(int RootDirectory, int Entries, Directory * directories){//reads the whole fo the root directory and outputs the information
    Directory dir;
    printf("|Starting Cluster\t| Last Modified\t\t| Attributes\t| Size\t| Name\t\t|\n");
    printf("-----------------------------------------------------------------------------------------\n");
    for (int j = 0; j < Entries; j++) {
        char *rootDir = sector_reader(sizeof(dir), RootDirectory, "fat16.img");
        memcpy(&dir, rootDir, sizeof(dir));
        free(rootDir);
        switch(dir.DIR_Name[0]){
            case 0x00:
                printf("-----------------------------------------------------------------------------------------\n");
                printf("No More Entries\n");
                return;
            case 0xE5:
                printf("deleted entry\n");
                break;
            default:
                print_directory(dir);
                directories[j] = dir;
            break;
        }
        
        RootDirectory += sizeof(dir);
    }
    
}

extern File * openFile (Volume * vol, File * file) {
    uint32_t starting_cluster = join(vol->dir.DIR_FstClusHI, vol->dir.DIR_FstClusLO);
    int dataoff = (vol->boot.BPB_RootEntCnt + vol->boot.BPB_RsvdSecCnt + vol->boot.BPB_NumFATs * vol->boot.BPB_FATSz16) * vol->boot.BPB_BytsPerSec;
    int sector_size = starting_cluster * vol->boot.BPB_BytsPerSec;
    
    int count = 0;
    int FAToffset = vol->boot.BPB_RsvdSecCnt * vol->boot.BPB_BytsPerSec;
    uint16_t clusters[32];
    cluster_reader(starting_cluster, FAToffset, 0, clusters);

    char sectors[32 * vol->boot.BPB_BytsPerSec];

    while (clusters[count] < 0xfff8) {
        int start_of_file = dataoff + sector_size;
        char *filedata = sector_reader(vol->dir.DIR_FileSize, start_of_file, vol->file);
        size_t dataSize = strlen(filedata);

        file->content = malloc(dataSize);
        if (file->content == NULL) {
            return NULL;  
        }
        memcpy(file->content, filedata, dataSize);

        // Free the memory allocated for filedata
        free(filedata);

        count++;
        sector_size = dataoff + (clusters[count] * vol->boot.BPB_BytsPerSec);
    }

    return file;
}

extern off_t seekFile ( File * file, off_t offset, int whence ){
    if(whence == 0){ //SEEK_SET
        file->offset = offset;
    }else if(whence == 1){ //SEEK_CUR
        file->offset = file->offset + offset; 

    }else if(whence == 2){ //SEEK_END
        file->offset = file->dir.DIR_FileSize;
    }else{
        return -1; //return if anythi g is wrong
    }
    return file->offset;

}
extern size_t readFile (File * file , void * buffer, size_t length ){
    memcpy(buffer, (file->content + file->offset), length);
    if(length > file->size){
        return 0; //EOF
    }else{
        return length;
    }
    
}
extern void closeFile (File * file){
    free(file);
}


int main(){
    BootSector boot;
    Volume fat16;
    fat16.boot = boot;
    fat16.file = "fat16.img";

    char * bootData = sector_reader(sizeof(boot), 0, fat16.file);
    memcpy(&boot, bootData, sizeof(boot));
    free(bootData);

    int FAToffset = boot.BPB_RsvdSecCnt * boot.BPB_BytsPerSec;

    print_BootSector(boot);

    uint16_t clusterArray [32];
    cluster_reader(6, FAToffset, 0, clusterArray);

    printf("Getting root Directory\n");
    int RootDirectory = (boot.BPB_RsvdSecCnt + boot.BPB_NumFATs * boot.BPB_FATSz16) * boot.BPB_BytsPerSec;
    Directory entries[boot.BPB_RootEntCnt];
    read_root_directory(RootDirectory, boot.BPB_RootEntCnt, entries);
    printf("%i", boot.BPB_RootEntCnt);
    
    print_directory(entries[18]);
    fat16.dir = entries[18];
    File file;
    openFile(&fat16, &file); 


 }


