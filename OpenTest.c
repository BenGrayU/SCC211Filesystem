 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <stdint.h>

//int open(const char * pathname, int flags);
//int creat(const char *pathname, mode_t mode);
//int openat(int dirfd, const char *pathname, int flags);
//int open(const char *pathname, int flags, mode_t mode);
//ssize_t read(int fd, void *buf, size_t count);
//int openat(int dirfd, const char *pathname, int flags, mode_t mode);
//off_t lseek(int fd, off_t offset, int whence);
//int close(int fd);

typedef struct __attribute__((__packed__)) {
uint8_t BS_jmpBoot[ 3 ]; // x86 jump instr. to boot code
uint8_t BS_OEMName[ 8 ]; // What created the filesystem
uint16_t BPB_BytsPerSec; // Bytes per Sector
uint8_t BPB_SecPerClus; // Sectors per Cluster
uint16_t BPB_RsvdSecCnt; // Reserved Sector Count
uint8_t BPB_NumFATs; // Number of copies of FAT
uint16_t BPB_RootEntCnt; // FAT12/FAT16: size of root DIR
uint16_t BPB_TotSec16; // Sectors, may be 0, see below
uint8_t BPB_Media; // Media type, e.g. fixed
uint16_t BPB_FATSz16; // Sectors in FAT (FAT12 or FAT16)
uint16_t BPB_SecPerTrk; // Sectors per Track
uint16_t BPB_NumHeads; // Number of heads in disk
uint32_t BPB_HiddSec; // Hidden Sector count
uint32_t BPB_TotSec32; // Sectors if BPB_TotSec16 == 0
uint8_t BS_DrvNum; // 0 = floppy, 0x80 = hard disk
uint8_t BS_Reserved1; //
uint8_t BS_BootSig; // Should = 0x29
uint32_t BS_VolID; // 'Unique' ID for volume
uint8_t BS_VolLab[ 11 ]; // Non zero terminated string
uint8_t BS_FilSysType[ 8 ]; // e.g. 'FAT16 ' (Not 0 term.)
} BootSector;

typedef struct {
    uint8_t DIR_Name[ 11 ]; // Non zero terminated string
    uint8_t DIR_Attr; // File attributes
    uint8_t DIR_NTRes; // Used by Windows NT, ignore
    uint8_t DIR_CrtTimeTenth; // Tenths of sec. 0...199
    uint16_t DIR_CrtTime; // Creation Time in 2s intervals
    uint16_t DIR_CrtDate; // Date file created
    uint16_t DIR_LstAccDate; // Date of last read or write
    uint16_t DIR_FstClusHI; // Top 16 bits file's 1st cluster
    uint16_t DIR_WrtTime; // Time of last write
    uint16_t DIR_WrtDate; // Date of last write
    uint16_t DIR_FstClusLO; // Lower 16 bits file's 1st cluster
    uint32_t DIR_FileSize; // File size in bytes
} Directory;


char * sector_reader(int len, off_t off, const char * file){ //sector reader returns pointer to full array of what it has read
    int desc = open(file, 0);
    lseek(desc, off, 0);
    char * buffer = malloc(len);
    read(desc, buffer, len);
    close(desc);
    return buffer;
}

void print_BootSector(BootSector boot){
    printf("Bytes Per Sector: %i\n", boot.BPB_BytsPerSec);
    printf("Sectors Per Cluster: %i\n", boot.BPB_SecPerClus);
    printf("Count Of Reserved Sectors: %i\n", boot.BPB_RsvdSecCnt);
    printf("Number Of FAT's: %i\n", boot.BPB_NumFATs);
    printf("Size Of Root Directory: %i\n", boot.BPB_RootEntCnt);
    printf("Sectors: %i\n", boot.BPB_TotSec16);
    printf("Sectors In FAT: %i\n", boot.BPB_FATSz16);
    printf("Bytes Per Sector: %i\n", boot.BPB_BytsPerSec);
    printf("Sectors if BPB_TotSec16 is equal to 0: %i\n", boot.BPB_TotSec32);
    printf("Non 0 Terminated String: ");
    for(int i = 0; i < 11; i++){
        printf("%c", boot.BS_VolLab[i]);
    }
    printf("\n");
}

void cluster_reader(int pos, int FAToffset){ //need to add to a list of all clusters
    uint16_t FATn = 0;
    int originalOffset = FAToffset;
    for(int i = 0; i < pos; i++){
        FAToffset = FAToffset+sizeof(uint16_t);
    }
    char * FATentr = sector_reader(sizeof(uint16_t), FAToffset, "fat16.img");
    memcpy(&FATn, FATentr, sizeof(FATn));
    if(FATn >= 0xfff8){
        printf("%i\n", FATn);
        printf("End of clusters\n");
        return;
    }
    printf("%i ->", FATn);
    cluster_reader(FATn, originalOffset);
}

uint32_t join(uint16_t higher, uint16_t lower){
    return ((higher << 16)| lower);
}

void convert_date_time(uint16_t date, uint16_t time){ //broken but close
    uint16_t year = 1980 + ((date >> 9) & 0x7F);
    uint16_t month = (date >> 5) & 0x0F;
    uint16_t day = date & 0x1F;
    printf("%i-%i-%i", year, month, day);
}

void print_directory(Directory dir){
    if(!(((dir.DIR_Attr & 0x0F) == 0x0F)&&(((dir.DIR_Attr >> 4) & 0x03) == 0x00))){
        uint32_t starting_cluster = join(dir.DIR_FstClusHI, dir.DIR_FstClusLO);
    printf("%u  ", starting_cluster);
        printf("    |   ");
    convert_date_time(dir.DIR_WrtDate, dir.DIR_WrtTime);
    printf("    |   ");
    for(int i = 0; i < 11; i++){
        printf("%c",dir.DIR_Name[i]);
        // if(i == 7){
        //     printf(".");
        // }
    }
    printf("\n");
    }
    
}

void read_root_directory(int RootDirectory, int Entries){
    Directory dir;

    for (int j = 0; j < Entries; j++) {
        char *rootDir = sector_reader(sizeof(dir), RootDirectory, "fat16.img");
        memcpy(&dir, rootDir, sizeof(dir));
        free(rootDir);
        switch(dir.DIR_Name[0]){
            case 0x00:
                printf("No More Entries\n");
                return;
            case 0xE5:
                printf("deleted entry\n");
                break;
            default:
                print_directory(dir);
            break;
        }
        
        RootDirectory += sizeof(dir);
    }
}


int main(){
    BootSector boot;

    char * bootData = sector_reader(sizeof(boot), 0, "fat16.img");

    memcpy(&boot, bootData, sizeof(boot));

    int FAToffset = boot.BPB_RsvdSecCnt * boot.BPB_BytsPerSec; //offset to get to FAT area

    print_BootSector(boot);

    cluster_reader(5, FAToffset);

    printf("Getting root Directory\n");
    int RootDirectory = (boot.BPB_RsvdSecCnt + boot.BPB_NumFATs * boot.BPB_FATSz16) * boot.BPB_BytsPerSec;
    read_root_directory(RootDirectory, boot.BPB_RootEntCnt);


 }


